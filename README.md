# Advent of Code 2022

链接: [Advent of Code 2022](https://adventofcode.com/2022)

## Day 10

- 每年都有的指令题来了，输入的处理依旧简单
- 这个 CPU 很简单，只有一个寄存器和两条指令
- 指令 noop 什么也不做，需要一个周期
- 指令 addx a 寄存器自增 a ，需要两个周期
- 寄存器的值只有在指令完全执行完成后才会更新
- 构造 CPU ，包含寄存器 register ，程序 program ，程序计数器 pc
- 仅有一个寄存器，所以 register 类型为 i32
- program 为指令列表
- pc 为指令指针，当前执行指令位置
- 当前指令为 noop 时，pc 加一即可
- 当前指令为 addx 时，因为这个指令需要两个周期，所以在第一次 addx 时，不对 register 进行修改，下一个周期再对 register 修改，然后 pc 加一
- 所以 CPU 中需要另外的计数器 cycle ，用于记录当前指令的执行周期数。因为只存在一个指令需要两周期，所以可以使用 bool 类型进行计数器。初始为 false ，表示不需要额外周期执行当前指令，只有当 pc 指向 addx 时，cycle 置为 true ，表示需要额外的一个周期。在下一个周期中，pc 虽然依旧指向 addx ，但是因为 cycle 为 true ，表示指令需要的额外周期已经完成，这时可以对 register 修改，同时 pc 指向下一条指令。
- 在指令寻址的部分，程序可能是循环执行的，即当程序运行结束时，pc 需要从头开始。在这个题目中其实不涉及这个问题，因为程序运行周期为 240 ，刚刚好在两个部分问题的范围内。按照往年题目，后续肯定有类似的扩展题，后续可能要考虑这一点。
- 第一部分需要计算 CPU 在某一个执行周期中寄存器的值。根据上述的 CPU 实现，只要按照周期运行即可，在特定周期时记录寄存器值计算信号强度。因为要求计算的是执行周期中寄存器的值，这时指令还没完成执行，寄存器的值没有更新，是和周期前寄存器值一致的。而且当前的实现，实际上一个周期是不存在执行中的情况的，所以直接用当前周期执行前寄存器的值。
- 第二部分看似复杂，需要绘制像素。绘制一个像素的过程分为两个部分：
    - 首先是 `sprite` ，可以视作画笔，宽度为 3 
        - `sprite` 的中间位置是寄存器的值，这个值是可能小于 1 的，所以画笔有作用的实际宽度会小于 3 
    - 然后是屏幕的部分，每一个计算周期中，只会更新一个像素，可以视作画布
    - 只有当画笔落在了画布上，像素才会被点亮
    - 令屏幕为 `screen: [[false; 40]; 6]` 初始时所有像素都没有点亮为 `false` ，屏幕宽度为 40 高度为 6
    - 屏幕的绘制方式是从左到右，从上到下，最初绘制的像素是 (0, 0) ，最后绘制的像素是 (5, 39)
    - 令当前绘制行 `cur_row` ，当前行中的位置 `cur_pos` 那么当前绘制的像素就是 `screen[cur_row][cur_pow]`
    - 那么只有当绘制像素落在 `sprite` 的范围内，像素才会被点亮，否则不变
        - 可以计算 `cur_pos` 和 `sprite` 中间位置的距离，如果距离小于 2 ，那么绘制像素落在 `sprite` 中
    - 当绘制的位置超出了行的边界，表示需要绘制下一行
- 因为绘制也是在一个执行周期中完成的，所以绘制是发生在周期完成前，需要先绘制，在执行周期
- 执行完所有的周期，第二个部分也就是 240 个周期，执行再多的周期也不会对屏幕有影响。这时得到的 screen 就是像素的明暗情况，根据对应位置值，绘制 '#' 和 '.' ，打印结果即可取得答案。我还记得写 18 年的题目的时候，也是一个绘制题，我画出了正确的结果，但是却认错字，今年的结果还是很清晰的。


## Day 9

- 第九天的问题难度并不大，输入的处理上也不复杂，在细节上需要考虑仔细
- 输入处理
    - 构造枚举类型 Move ，类型内部数据为步数
    - 实现 trait FromStr 将一行输入构造对应的 Move 类型
- 第一个部分的绳子很短，只有两个结，尾部的结 T 随着头部结 H 移动 
- T 跟随 H 移动的规则如下
    - 如果 H 和 T 直接相邻或者重合那么 T 不移动
    - 如果 H 和 T 处于同一行或同一列，而且距离为 2 ，那么 T 向 H 的方向移动一步。如果每一次移动都严格按照移动规则进行移动，当 H 和 T 同属一行或一列时，他们的距离不可能超过 2 ，同时 T 当新位置就是 H 和 T 的中位，所以可以不用考虑 H 的移动方向，直接计算中位即可 T = (H + T)
    - 如果 H 和 T 处于对角线，同时距离为 2，那么这个时候 T 不移动
    - 如果 H 和 T 的距离大于 2 ，那么 T 的移动方向是对角线，这个时候 T 有四个可能的移动方向，可以发现四种情况中只有一种可以缩短 H 和 T 的距离，所以遍历四种可能，确定唯一的移动路径即可
    - 更加简便的规则：
    > https://github.com/ropewalker/advent_of_code_2022/blob/master/src/day09.rs
- 移动的情况是随意的，所以假想的地图应该是无限大的，那么利用 Vec 来抽象地图就不方便了，而且题目的要求中并不需要真正的抽象地图，而只需要计算某一个绳结所有的访问位置，那么可以利用 HashSet 来进行存储，值为对应的绳结坐标即可。
- 同样的对于 H 和 T 也只需要关注每一颗的坐标即可。
- 对 Move 实现方法 get_step 和 move_fn 来快速取得 H 需要移动的步数和移动的方法，move_fn 方法返回函数闭包，能够传入参数快速计算出 H 的下一个位置。
- 第一个部分的解答就很容易了，因为只有两个结 H 和 T ，为了防止混乱（步子迈太大容易扯到自己），所以一步一步计算，对于每一步，首先利用 move_fn 的方法移动 H ，再根据移动规则移动 T ，将 T 的新位置存入 HashSet 。最后 HashSet 的长度即是 T 到访过的所有位置。
- 第二个部分看似复杂，绳结的数量增加到了 10 个，构建 ropes ，c长度为 10 ，初始时每一个绳结的位置都为 (0, 0)，索引 0 为 H 的坐标，索引 9 为 T 的坐标。依旧是一步一步的考虑，对于每一步，移动总是从头部开始，所以当 i 为 0 时，利用 move_fn 移动头部。对于其他绳结，利用移动规则计算下一个位置 `ropes[i + 1] = move_tail(ropes[i], ropes[i + 1])` 可以理解 i 是头部和 i + 1 是尾部，实际上这就是第一部分。需要记录尾部的访问情况，所以当 i 为 8 时，也就是计算 `ropes[i + 1]` ，这个时候将 `ropes[i + 1]` 的位置存入 HashSet 。同样的最后 HashSet 的长度即是 T 到访过的所有位置。
- 如果花费大量的时间，也是可以不一步一步的来，但是那就要花费大量时间分析 H 和 T 的对应情况，而且这个问题需要确定 T 的移动路径，那么对这个问题来说可能没有必要。

## Day 8

- 今天这一题考虑过度，导致花了很长的时间，最后是直接暴力完成的，运行速度不慢
- 输入的处理很简单，直接按照字符划分即可，再将每个字符转为数字即可
- 对于每一个位置，实际上只存在四个观测路径，朝上下左右四个方向看，直到实现被阻挡或者尽头（边界）
- **搜索最远可见树的位置**：考虑一个位置 (x, y)，树高为 h， 从这个位置向左遍历所有树高度小于 h 的位置，当遍历到的位置树高大于 h 或 遍历到边界时，遍历结束，结束时的位置即为 (hx, hy)
- 对于第一部分，如果位置 (hx, hy) 是处于边界的，那么起始位置 (x, y) 是可以从边界之外看见的树。那么只要遍历网格中所有的位置，同时对每一个位置，进行四个方向的搜索，最后就能确定所有能够从边界处看见的树。
- 对于第二个部分，从位置 (x, y) 搜索到最远可见的树的位置 (hx, hy) ，在这两个位置间存在树的数量即是计算分数的一部分，因为搜索只能是笔直方向的，所以两个位置的差距即是可见树的数量，如果 (hx, hy) 是在边界上，那么在这之外是看不见一棵树的，但是如果 (hx, hy) 不在边界上，那么视线被 (hx, hy) 的树阻挡，这一棵树也要计入，需要在结果上加一。计算四个方向上可见树的数量，再累积即可。最后对所有位置上的分数取最大值即可（或者搜索时同时计算最大值）。
- 考虑网格的大小为 n * n （方便起见设为正方形），每一次搜索的路径都是笔直的，所以一个位置对一个方向上的搜索，最多需要比较 n 次，时间复杂度为 O(n) ，那么所有位置对一个方向的搜索的时间复杂度是 O(n^3) ，四个方向上搜索的时间复杂度就会是 O(4n^3) 。
- **可能有的优化**：正是这个地方让我花费了大量的时间，最初我并没有意识到搜索的路径是笔直的，所以实际上是在四个方向上进行四次毫无关联的搜索。因为给定输入的网格大小只是 100 ，所以即是没有优化，最后的时间复杂度也不会过高，程序依旧能较快完成。
- **优化——记忆化搜索**：
    - 第一部分：考虑输入中的一行 123 ，从左到右依次编号 1、2、3，那么考虑向左搜索，搜索 1 号时，不需要进行比较，已经处在边界，所以 1 肯定是从左边界可见的，搜索 2 号时，需要和 1 号进行比较，抵达边界不再需要其他的比较，所以 2 也是左边界可见的。考虑 3 号的搜索，默认情况下 3 号要和 2 号比较，然后再同 1 号比较，所以需要比较两次，但是实际上在和 2 号进行比较的时候，因为 2 号已知可以被看见，所以只需要进行一次比较即可。这个优化的麻烦点在于四个方向上的搜索是独立的，所以需要进行四次记忆化。
    - 第二部分实际上也可以用这样的方法进行记忆化，当前位置为 (x, y) 在比较下一个位置 (x1, y1) 时，如果当前树高于下一个树，那么实际上可以直接和下一个树可见位置 (hx1, hy1) 进行比较，因为 (x1, y1) 位置的树高一定大于 (hx1, hy1) 处的树高，那么中间那些重复的比较实际上就可以略过，减少了计算。同样的这个记忆化在不同方向上是独立的，需要单独存储。
- 现在看来好像这些优化也并非特别复杂，这是因为我已经完成了基础版本的代码，在这基础上再进行优化会比从写第一行代码时就开始考虑优化要容易很多。可以说是步子迈的太大以至于浪费了时间，也弄乱了思路。

## Day 7

- 这一题要求根据命令和结果构造存储结构，应该是不难的一题，但是我却花了两个小时
- 输入包含两个部分，命令和命令输出结果
- 只有两条命令 cd 和 ls 
- cd 表示进入目录，这个命令无输出结果
- ls 表示输出当前目录结构
- ls 的命令输出结果中也包含两部分
- 例如 dir a 表示存在子目录 a
- 和 14848514 b.txt 表示存在文件 b.txt 大小为 14848514
- 对输入的处理并不难，但是 cd 命令中存在两个特殊的情况， `cd /` 和 `cd ..` ，也就是说进入子目录后需要能够回到上层目录和根目录
- 第一部分需要在确定目录结构之后，计算每一个目录的大小，再计算目录小于 1000000 的目录大小总和
- 第二部分需要确定再删除了哪一个目录后能够空出需要的空间，所以同样需要计算每一个目录的大小。
- 如果能够正确的表示目录结构那么就能够轻易的求解。
- **构造树有些大材小用，如果要计算目录大小，可以模拟完成。**处理输入时记录文件夹结构，同时计算文件夹下文件大小的总和，完成输入处理后，再递归计算子文件夹大小，这样就能确定所有文件夹的大小。
    - 转移方程 f(dir) = sum{f(sub_dir)} + sum{f(file)}
    - 边界情况：当文件夹不存在子文件夹时，f(dir) = sum{f(file)}

### 构造树

1. 初步构造 Dir 
```rust
struct Dir {
    name: String,
    sub_dir: HashMap<String, Dir>,
    files: HashMap<String, File>,
    size: Option<usize>,
    parent: Option<Dir>,
}
```
这时最初的文件夹思路，但是这样的做法存在严重的问题，问题就在于对上层文件夹的访问，如果将文件夹结构视为树，那么也就是子节点需要访问父节点，那么这样的 Dir 是无法满足需求的，虽然也有 parent 但是会导致所有权的问题，一般来说构造树的时候需要使用 `Rc<RefCell<Box<T>>>` 但是我并不想这样做，太复杂了。所以我参考了 https://rust-leipzig.github.io/architecture/2016/12/20/idiomatic-trees-in-rust/ 中构造树的方法。

2. 增加 Dirs ，利用 Vec 和节点索引值来构造树结构
```rust
struct Dirs {
    dirs: Vec<Dir>,
    next_index: usize,
}
```

3. 调整 Dir 为
```rust
struct Dir {
    id: usize,
    sub_dir: Vec<usize>,
    table: HashMap<String, usize>,
    files: HashMap<String, usize>,
    parent: usize,
}
```
- sub_dir 中只保存子目录的索引值
- table 中保存子目录名称和索引值的对应
- id 当前目录的索引值

这样修改之后既可以实现子节点快速访问父节点，又可以保证树的结构


4. 构造 File 

File 较为简单，只需要包含文件名和大小，可以视为树的叶子节点。可以优化直接优化为 HashMap ，而不需要额外的结构，直接用哈希表存储文件名和大小即可。
```rust
struct File {
    name: String,
    size: usize
}
```

### 模拟

1. 首先对输入进行处理
    - 构造栈 pwd 存储档期当前目录的绝对路径
    - `cd ..` pwd 弹出栈顶
    - `cd \` pwd 设为 `vec!["/"]`
    - `cd name` pwd 压入 name
    - 对于 ls 命令，需要完成两件事情，
        1. 记录当前路径下所有的子目录
        2. 记录当前路径下所有文件的大小和
    - 构造 `sub_dirs: HashMap<String, Vec<&str>>` 来存放每一个路径对应的子目录
    - 构造 `sizes: HashMap<String, usize>` 存放每一个路径的大小
    - 对输入进行处理时，是没法直接计算出文件夹大小的，读取当前文件夹时子文件夹的情况还没读取和处理，所以输入处理时只能计算出一部分的文件夹大小（文件部分）
2. 当已经完成所有文件结构的确定，即完成输入同时也完成构造 `sub_dirs` 时 
    - 从根目录计算每一个文件夹的大小
    - 如果当前目录没有任何子文件夹，那么输入时计算的所有子文件大小总和即是当前文件夹的大小，不更新 `sizes`
    - 如果当前目录存在子文件夹，那么递归计算子文件夹的大小，确定所有子文件夹大小后，更新 `sizes`


## Day 6

- 依旧是不复杂的一题，对输入的处理也很简便
- 读入字符串，转为字符数组
- 第一个部分要求寻找最早出现的四个完全不同的连续字符的位置
- 第二个部分要求寻找最早出现的十四个完全不同的连续字符的位置
- 考虑直接暴力的方法，单指针，从零开始，每次截取所需要的长度的字符数字，存入 Set ，判断 Set 的长度是否不变，如果不变说明截取部分不存在重复，如果发生变化则向右移动指针，继续判断。

## Day 5

- 这一题的难点在于如何处理输入，如果不从文件中读取，而是直接根据输入手动写栈，那么最后的结果应该还能向前
- 首先确定每一行的输入类型
- 如果是以 move 开头，那么输入为操作类型，根据空格进行划分，取出中的数字，第一个数字表示移动数量，第二个数字为初始栈，第三个数字为目的栈。
- 如果为空行则跳过
- 其他的行都是初始栈的一部分，输入是很形象的栈，所以第一行是所有栈的顶部，自上而下栈顶到栈底。
    - 每一个大写字母代表一个集装箱，其他的字符都无意义，但是可以发现即使是空的栈，输入中也包含了空格
    - 利用 char_indices 获取每一行中的字符，以及对应位置，需要将字符位置对应到具体的栈索引
    - 正常情况下，输入中表示集装箱需要使用三个字符，同时使用一个空白和隔壁的栈表示分割，可以考虑从字符 '[' 到空白的四个字符都属于当前栈，第一个栈的字符位置应当是 0 到 3（都包涵），第 N 个栈的字符位置应当是 (N - 1) * 4 到 (N - 1) * 4 + 3
    - 那么实际上只要将代表集装箱的大写字符的位置除以 4 就可以得到栈的索引，而且因为索引从 0 开始，所以得到的就是具体的索引，不必加一
    - 当需要将集装箱压入的栈不存在时，即索引大于栈的数量时，需要构造空栈。
    - 而且根据输入是从顶部开始入栈，最后得到的结果是相反的，所以构造完之后也需要对每一个栈进行逆序操作。
- 第一个部分实际上只要按照栈的要求即可，根据输入的步骤不断的进行 pop 和 push 操作即可，注意输入中栈的索引是从 1 开始
- 第二个部分不再是一个一个移动，而是一次性移动好几个，不是纯粹的栈操作。当然可以全都 pop 存放到中间栈，再将最后的结果存入目的栈。但是在这里我直接使用了 Rust 中 Vec 的方法，利用 split_off 直接截取需要移动的元素，然后再利用 extend_from_slice 移入目标栈。

## Day 4

- 这是一道区间题，判断两个区间的重叠情况
- 对输入进行预处理
    - 首先对每行根据 ‘,’ 进行分割
    - 再对每个部分根据 ‘-’ 进行分割
    - 再将字符串转为数字构造具体区间
- 第一个部分需要判断每行的两个区间存在完全重叠的情况
    - ~~可以根据区间的起点进行排序，设起点较小的区间为 p1 ，这时如果 p2 的终点小于 p1 的终点，那么完全重叠~~
    - 仅仅根据起点进行排序是不够的，例如对于区间 (14, 39) 和 (14, 85) ，按照起点排序，那么顺序不变，这时 p2 区间的终点是不小于 p1 区间的终点的，所以按照这个逻辑这两个区间是不存在完全重叠的，和实际相反。
    - **排序逻辑：**按照起点排序，起点相同时按照终点倒序，即终点较大的区间为 p1 。
    - 如果不进行排序，需要进行两次比较，实际上在这个部分，两次比较的方法更加不容易出错。 (p1.0 <= p2.0 && p1.1 >= p2.1) || (p1.0 >= p2.0 && p1.1 <= p2.1)
- 第二个部分需要判断每行的两个区间存在重叠的情况
    - 可以根据区间的起点进行排序，设起点较小的区间为 p1 ，这时如果 p2 的起点不大于 p1 的终点，那么必然存在重叠
    - 因为按照起点排序，所以 p2 的起点一定大于等于 p1 的起点，如果两个区间重叠，那么只要 p2 的起点都在 p1 区间中，这时两个区间一定存在重叠。
    - 这里的排序实际上并没有第一个部分排序时的忧虑，考虑两个区间起点相同（实际上这时已经存在重叠），这个起点都会小于两个区间的终点，也就是说一定存在重叠。

## Day 3

- 第一个部分和第二个部分的问题实际上是一致的：取得所有都出现在几个字符串中的字符
- 可以进一步化简为，取得所有都出现在几个序列中的元素
- 第一个部分每一行输入需要一分为二，然后进行计算
- 第二个部分则是每三行输入需要进行计算
- 通过 b as u8 - 'A' as u8 + 27 可以将大写字符转为题目要求的权重
- 通过 b as u8 - 'a' as u8 + 1 可以将小写字符转为题目要求的权重
- 每个字符可能在一个序列中重复出现，所有对于一个序列中的字符，只计算一次出现的情况
- 第一部分：
    - 构造一个 dup 数组，元素类型为 (bool, bool) ，长度 53 ，数组下标对应相应字符权重对应字符
    - 第一个元素表示当前字符在前一半的输入中出现情况，第二个元素表示当前字符在后一般的输入出现情况。
    - 当元素值为 (true, true) 时则表示当前字符即出现在前一半输入，又出现在后一半输入。
- 第二部分和第一部分一致，只不过 dup 数组的元素需要增加一个元素，应对新增的第三个输入
- 更多解法
    - 使用位运算，最多有 52 个不同字符，可以利用 u64 来保存一个输入序列的出现情况，最后计算结果时可以对不同序列的出现情况进行与运算，然后再计算位为 1 的位置和
    

## Day 2

- 依旧考察的是对于输入的处理，并不涉及复杂逻辑。自己实现的时候在对于输入的解析上过于复杂了，如果仅仅为了得出结果，完全可以直接处理字符，但是这样的实现便于阅读，也可以练习实现一些常见的 Trait
- 第一个部分输入均为手势
    - 构造枚举类型 Shape 对应手势
    - 通过实现 Trait FromStr 可以很容易的将 A B C X Y Z 六个不同的字符串对应到不同的手势
    - 通过实现 Trait Sub 实现不同手势间的计算结果，实现结果计算
        - 也可以实现 Traid Ord 实现不同手势的大小比较，同样实现结果计算
- 第二个部分第一列输入为手势，第二列输入为结果
    - 对第一列依旧实现字符解析，对应 Shape
    - 构造枚举类型 Outcome 对应不同的结果
    - 不再实现 Trait ，而是直接利用 match ，根据两列的输入计算结果
- 分数计算：根据给出的手势和结果进行计算每一轮的分数
    - 石头：1 分
    - 步：2 分
    - 剪刀： 3 分
    - 输：0 分
    - 平：3 分
    - 赢：6 分

## Day 1

- 首先对输入进行处理
    - 输入数据为每个精灵所携带（不同）食物的卡路里数
    - 一个精灵可能对应多个卡路里数
    - 不同精灵通过空行分割
    - 最初设想保留每一个卡路里数
- 第一个部分计算最大的精灵携带食物卡路里数
    - 不需要每一个精灵中每一个卡路里数
- 第二个部分计算前三的精灵携带食物卡路里数
    - 同样不需要每一个分别的卡路里数
- 可以在输入时就计算每一个精灵携带食物的卡路里总数
- 第一个部分直接使用 max 取得，时间复杂度应该是 O(n)
- 第二个部分将转化后的输入数据存入最大堆 (O(n))，取三次堆顶，累加即是结果，时间复杂度是 O(logn)
- 也可以直接对输入数据进行反向排序 O(nlogn)，第一个部分取第一个元素，第二个部分的问题则是前三元素的和