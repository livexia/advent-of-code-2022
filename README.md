# Advent of Code 2022

链接：[https://adventofcode.com/2022](https://adventofcode.com/2022)

## Day 3

- 第一个部分和第二个部分的问题实际上是一致的：取得所有都出现在几个字符串中的字符
- 可以进一步化简为，取得所有都出现在几个序列中的元素
- 第一个部分每一行输入需要一分为二，然后进行计算
- 第二个部分则是每三行输入需要进行计算
- 通过 b as u8 - 'A' as u8 + 27 可以将大写字符转为题目要求的权重
- 通过 b as u8 - 'a' as u8 + 1 可以将小写字符转为题目要求的权重
- 每个字符可能在一个序列中重复出现，所有对于一个序列中的字符，只计算一次出现的情况
- 第一部分：
    - 构造一个 dup 数组，元素类型为 (bool, bool) ，长度 53 ，数组下标对应相应字符权重对应字符
    - 第一个元素表示当前字符在前一半的输入中出现情况，第二个元素表示当前字符在后一般的输入出现情况。
    - 当元素值为 (true, true) 时则表示当前字符即出现在前一半输入，又出现在后一半输入。
- 第二部分和第一部分一致，只不过 dup 数组的元素需要增加一个元素，应对新增的第三个输入
- 更多解法
    - 使用位运算，最多有 52 个不同字符，可以利用 u64 来保存一个输入序列的出现情况，最后计算结果时可以对不同序列的出现情况进行与运算，然后再计算位为 1 的位置和
    

## Day 2

- 依旧考察的是对于输入的处理，并不涉及复杂逻辑。自己实现的时候在对于输入的解析上过于复杂了，如果仅仅为了得出结果，完全可以直接处理字符，但是这样的实现便于阅读，也可以练习实现一些常见的 Trait
- 第一个部分输入均为手势
    - 构造枚举类型 Shape 对应手势
    - 通过实现 Trait FromStr 可以很容易的将 A B C X Y Z 六个不同的字符串对应到不同的手势
    - 通过实现 Trait Sub 实现不同手势间的计算结果，实现结果计算
        - 也可以实现 Traid Ord 实现不同手势的大小比较，同样实现结果计算
- 第二个部分第一列输入为手势，第二列输入为结果
    - 对第一列依旧实现字符解析，对应 Shape
    - 构造枚举类型 Outcome 对应不同的结果
    - 不再实现 Trait ，而是直接利用 match ，根据两列的输入计算结果
- 分数计算：根据给出的手势和结果进行计算每一轮的分数
    - 石头：1 分
    - 步：2 分
    - 剪刀： 3 分
    - 输：0 分
    - 平：3 分
    - 赢：6 分

## Day 1

- 首先对输入进行处理
    - 输入数据为每个精灵所携带（不同）食物的卡路里数
    - 一个精灵可能对应多个卡路里数
    - 不同精灵通过空行分割
    - 最初设想保留每一个卡路里数
- 第一个部分计算最大的精灵携带食物卡路里数
    - 不需要每一个精灵中每一个卡路里数
- 第二个部分计算前三的精灵携带食物卡路里数
    - 同样不需要每一个分别的卡路里数
- 可以在输入时就计算每一个精灵携带食物的卡路里总数
- 第一个部分直接使用 max 取得，时间复杂度应该是 O(n)
- 第二个部分将转化后的输入数据存入最大堆 (O(n))，取三次堆顶，累加即是结果，时间复杂度是 O(logn)
- 也可以直接对输入数据进行反向排序 O(nlogn)，第一个部分取第一个元素，第二个部分的问题则是前三元素的和